# Exercise 1

You are working as a software engineer for a large-scale data processing company that handles thousands of records daily. The company frequently processes large datasets and requires efficient sorting algorithms to maintain high performance. Two sorting algorithms—Merge Sort and Quick Sort—are often discussed for their efficiency, but each has strengths and weaknesses depending on the size and structure of the data. Your task is to implement and compare the performance of Merge Sort and Quick Sort, analyzing their time complexities and measuring their execution times on datasets of different sizes.

As a part of the project, you need to decide which sorting algorithm to use for different scenarios based on empirical results. To do this, you will implement both algorithms, test them with datasets of varying sizes, and compare their performance in terms of execution time and algorithmic efficiency.

Additionally, the company deals with large matrix computations, and matrix multiplication plays a key role in various applications such as machine learning and data analysis. You are asked to explore the optimization of matrix multiplication by comparing the performance of Strassen’s Matrix Multiplication algorithm with the traditional Naive Matrix Multiplication approach.


1. Implement the Merge Sort and Quick Sort algorithms in any programming language using the Divide and Conquer approach.
2. Analyze and compare the time complexity of both algorithms using Big-O notation.
   1. Empirically test both algorithms using randomly generated datasets of different sizes (e.g., 10, 50, 100 elements).
   2. Report the execution times for both algorithms and compare how their performance scales as the input size increases.
3. Discuss the strengths and weaknesses of both algorithms, providing insights into which one is more efficient under specific circumstances (e.g., small vs large datasets).
4. Explain how Strassen's algorithm reduces the number of multiplications compared to the naive method.
